// external dependencies
const spawn = require('child_process').spawn;
const phantom = require('phantomjs-prebuilt');
const _ = require('lodash');
const bPromise = require('bluebird');
const os = require('os');
const fs = require('fs');
const path = require('path');
const uuid = require('uuid');

// constants/variables
const defaultOptions = {
  height: '10.5in',
  width: '8in',
  orientation: 'portrait',
  quality: 75,
  timeout: 30000,
  assetsDirectory: null,
  header: {
    height: '26mm'
  },
  footer: {
    height: '18mm'
  }
};

// logic
function PdfReport(html, options) {
  // save references to important variables that need to be used later
  this.html = html;
  this.options = _.extend({}, defaultOptions, options);
  this.fileName = path.join(os.tmpdir(), uuid.v4() + '.pdf');
}

PdfReport.prototype.exitThread = function() {
  this.thread.stdin.end();
  this.thread.kill();
};

PdfReport.prototype.cancelThreadTimeout = function() {
  if (this.threadTimeout) {
    clearTimeout(this.threadTimeout);
    this.threadTimeout = null;
  }
};

PdfReport.prototype.generateReport = function() {
  return new bPromise(function(resolve, reject) {
    const scriptPath = path.join(__dirname, 'generate-pdf.js');
    var errorThrown = null;

    // spawn a new phantomjs thread and pass it our PDF generation script
    this.thread = spawn(phantom.path, [scriptPath]);

    // set a timeout that will prevent long-hanging scripts from exiting
    this.threadTimeout = setTimeout(function() {
      this.threadTimeout = null;
      errorThrown = 'Report generation timed out';
      this.exitThread();
    }.bind(this), this.options.timeout);

    // listen for any errors sent to stdout on the child thread
    this.thread.stderr.on('data', function(buffer) {
      errorThrown = 'An error occurred: ' + buffer.toString();
      this.exitThread();
    }.bind(this));

    this.thread.stdout.on('data', function(buffer) {
      console.log(buffer.toString());
    });

    // listen for any errors on the child thread itself
    this.thread.on('error', function() {
      errorThrown = 'An unknown error has occurred';
      this.exitThread();
    }.bind(this));

    // listen for when the child thread has exited
    this.thread.on('exit', function() {
      this.cancelThreadTimeout();

      if (errorThrown) {
        return reject(new Error(errorThrown));
      }

      return resolve(this.fileName);
    }.bind(this));

    // finally, pipe the HTML and options to the phantomjs thread
    this.thread.stdin.write(JSON.stringify({
      html: this.html,
      options: this.options,
      fileName: this.fileName
    }) + '\n', 'utf8');
  }.bind(this));
};

PdfReport.prototype.toFile = function(newPath) {
  return this.generateReport()
    .then(function(filePath) {
      return new bPromise(function(resolve, reject) {
        fs.rename(filePath, newPath, function(error) {
          if (error) {
            return reject(new Error('Could not move file'));
          }

          resolve(newPath);
        });
      });
    });
};

PdfReport.prototype.toStream = function() {
  return this.generateReport()
    .then(function(filePath) {
      const stream = fs.createReadStream(filePath)

      stream.on('end', function() {
        fs.unlink(filePath, _.noop);
      });

      return bPromise.resolve(stream);
    });
};

PdfReport.prototype.toBuffer = function() {
  return this.generateReport()
    .then(function(filePath) {
      return new bPromise(function(resolve, reject) {
        fs.readFile(filePath, function(error, buffer) {
          fs.unlink(filePath, _.noop);

          if (error) {
            return reject(new Error('Unable to create buffer'));
          }

          return resolve(buffer);
        });
      });
    });
};

// export this logic
exports = module.exports = PdfReport;
